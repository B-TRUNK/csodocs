"A type that is defined as a class is a reference type. 
At run time, when you declare a variable of a reference type,
the variable contains the value null until you explicitly create an instance of the
class by using the new operator,
or assign it an object of a compatible type created elsewhere

When the object is created, enough memory is allocated on the managed heap for that
specific object, and the variable holds only a reference to the location of said object.
The memory used by an object is reclaimed by the automatic memory management functionality
of the Common Language Runtime (CLR), which is known as garbage collection. 

Every .NET type has a default value. Typically, that value is 0 for number types,
and null for all reference types. You can rely on that default value when it's 
reasonable in your app."

------------------------------------------------------------------------------------------


**Beginning with C# 12, you can define a "primary constructor" as part of the class declaration:
public class Container(int capacity)
{
    private int _capacity = capacity;
}

You can also use the required modifier on a property and allow callers to use an object initializer to set the initial value of the property:
public class Person
{
    public required string LastName { get; set; }
    public required string FirstName { get; set; }
}

The addition of the required keyword mandates that callers must set those properties as part of a new expression:

var p1 = new Person(); // Error! Required properties not set
var p2 = new Person() { FirstName = "Grace", LastName = "Hopper" };

-----------------------------------------------------------------------------------------------------
*Inheritance
============
When you create a class, you can inherit from any other class that isn't defined as "sealed"

A class can be declared as abstract. An abstract class contains abstract methods that have a signature definition but no
implementation. Abstract classes can't be instantiated. They can only be used through derived classes that
implement the abstract methods. By contrast, a sealed class doesn't allow other classes to derive from it.
For more information, see Abstract and Sealed Classes and Class Members.

------------------------------------------------------------------------------------

Introduction to record types in C#
==================================
A record in C# is a class or struct that provides special syntax and behavior for
working with data models. The record modifier instructs the compiler to synthesize
members that are useful for types whose primary role is storing data.
These members include an overload of ToString() and members that support value equality.

When to use records
-------------------
Consider using a record in place of a class or struct in the following scenarios:

    - You want to define a data model that depends on value equality.
    - You want to define a type for which objects are immutable.

Value equality
--------------
For records, value equality means that two variables of a record type are equal if the
types match and all property and field values compare equal.
For other reference types such as classes, equality means reference equality by default,
unless value equality was implemented. That is, two variables of a class type are equal
if they refer to the same object. Methods and operators that determine equality of
two record instances use value equality.

Not all data models work well with value equality. For example, Entity Framework Core 
depends on reference equality to ensure that it uses only one instance of an 
entity type for what is conceptually one entity. For this reason,
record types aren't appropriate for use as entity types in Entity Framework Core.

Immutability

An immutable type is one that prevents you from changing any property or field values of
an object after it's instantiated. Immutability can be useful when you need a type to be
thread-safe or you're depending on a hash code remaining the same in a hash table.
Records provide concise syntax for creating and working with immutable types.