Delegates (C# Programming Guide)
--------------------------------
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/


A delegate is a type that represents references to methods with a particular 
parameter list and return type. 
When you instantiate a delegate, you can associate the delegate instance with any 
method that has a compatible signature and return type. 
You can invoke (or call) the method through the delegate instance.

Delegates are used to pass methods as arguments to other methods. Event handlers are 
essentially methods you invoke through delegates. When you create a custom method, 
a class such as a Windows control can call your method when a certain event occurs.

The following example shows a delegate declaration:
-----------------------------------------------------
public delegate int PerformCalculation(int x, int y);
-----------------------------------------------------

You can assign any method from any accessible class or struct that matches the 
delegate type to the delegate. The method can be either static or an instance method.
The flexibility allows you to programmatically change method calls, or plug new code
into existing classes.

**Note
In the context of method overloading, the signature of a method doesn't include the 
return value. However, in the context of delegates, the signature does include the 
return value. In other words, a method must have a compatible return type as the 
return type declared by the delegate.

The ability to refer to a method as a parameter makes delegates ideal for defining 
callback methods. You can write a method that compares two objects in your application.
The method can then be used in a delegate for a sort algorithm. Because the 
comparison code is separate from the library, the sort method can be more general.

Function pointers 
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers
support similar scenarios, where you need more control over the 
calling convention. The code associated with a delegate is invoked by using a virtual
method added to a delegate type. When you work with function pointers, you can specify 
different conventions.

Explore delegate characteristics
Delegates have the following characteristics:
---------------------------------------------
    Delegates allow methods to be passed as parameters.
    Delegates can be used to define callback methods.
    Delegates can be chained together, such as calling multiple methods on a single 
    event.

    Methods don't have to match the delegate type exactly. For more information, 
    see Using Variance in Delegates.
    https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates

    Lambda expressions are a more concise way of writing inline code blocks. 
    Lambda expressions (in certain contexts) are compiled to delegate types. For more 
    information about lambda expressions, see Lambda expressions.
    https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions

===================================================================================
Using Delegates (C# Programming Guide)
--------------------------------------
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/using-delegates


A delegate is a type that safely encapsulates a method, similar to a function pointer 
in C and C++. Unlike C function pointers, delegates are object-oriented, type safe, 
and secure. The following example declares a delegate named Callback that can 
encapsulate a method that takes a string as an argument and returns void:

----------------------------------------------
public delegate void Callback(string message);
----------------------------------------------

A delegate object is normally constructed by providing the name of the method the 
delegate wraps, or with a lambda expression. A delegate can be invoked once 
instantiated in this manner. Invoking a delegate calls the method attached to the 
delegate instance. The parameters passed to the delegate by the caller are passed 
to the method. The delegate returns the return value, if any, from the method. 
For example:

-------------------------------------------------
// Create a method for a delegate.
public static void DelegateMethod(string message)
{
    Console.WriteLine(message);
}
-------------------------------------------------

----------------------------------
// Instantiate the delegate.
Callback handler = DelegateMethod;

// Call the delegate.
handler("Hello World");
----------------------------------

Delegate types are derived from the Delegate class in .NET. Delegate types are 
sealed, they can't be derived from, and it isn't possible to derive custom classes 
from Delegate. Because the instantiated delegate is an object, it can be passed as 
an argument, or assigned to a property. A method can accept a delegate as a 
parameter, and call the delegate at some later time. This is known as an 
asynchronous callback, and is a common method of notifying a caller when a long 
process completes. When a delegate is used in this fashion, the code using the 
delegate doesn't need any knowledge of the implementation of the method being used. 
The functionality is similar to the encapsulation interfaces provide.

Another common use of callbacks is defining a custom comparison method and passing 
that delegate to a sort method. It allows the caller's code to become part of the 
sort algorithm. The following example method uses the Callback type as a parameter:

--------------------------------------------------------------------------------
public static void MethodWithCallback(int param1, int param2, Callback callback)
{
    callback("The number is: " + (param1 + param2).ToString());
}
--------------------------------------------------------------------------------

When a delegate is constructed to wrap an instance method, the delegate references 
both the instance and the method. A delegate has no knowledge of the instance type 
aside from the method it wraps. A delegate can refer to any type of object as long 
as there's a method on that object that matches the delegate signature. When a 
delegate is constructed to wrap a static method, it only references the method. 
Consider the following declarations:

-------------------------------------------
public class MethodClass
{
    public void Method1(string message) { }
    public void Method2(string message) { }
}
--------------------------------------------

Along with the static DelegateMethod shown previously, we now have three methods 
that you can wrap in a Callback instance.

A delegate can call more than one method when invoked, referred to as multicasting. 
To add an extra method to the delegate's list of methods—the invocation list—simply 
requires adding two delegates using the addition or addition assignment operators 
('+' or '+='). For example:

--------------------------------------
var obj = new MethodClass();
Callback d1 = obj.Method1;
Callback d2 = obj.Method2;
Callback d3 = DelegateMethod;

//Both types of assignment are valid.
Callback allMethodsDelegate = d1 + d2;
allMethodsDelegate += d3;
---------------------------------------

The allMethodsDelegate contains three methods in its invocation list—Method1, 
Method2, and DelegateMethod. The original three delegates, d1, d2, and d3, remain 
unchanged. When allMethodsDelegate is invoked, all three methods are called in 
order. If the delegate uses reference parameters, the reference is passed 
sequentially to each of the three methods in turn, and any changes by one method 
are visible to the next method. When any of the methods throws an exception that 
isn't caught within the method, that exception is passed to the caller of the 
delegate. No subsequent methods in the invocation list are called. If the delegate 
has a return value and/or out parameters, it returns the return value and 
parameters of the last method invoked. To remove a method from the invocation list, 
use the subtraction or subtraction assignment operators (- or -=).

https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/subtraction-operator 

For example:
--------------------------------------------------------
//remove Method1
allMethodsDelegate -= d1;

// copy AllMethodsDelegate while removing d2
Callback oneMethodDelegate = (allMethodsDelegate - d2)!;
--------------------------------------------------------

Because delegate types are derived from System.Delegate, the methods and properties 
defined by that class can be called on the delegate. For example, to find the number 
of methods in a delegate's invocation list, you can write:

----------------------------------------------------------
int invocationCount = d1.GetInvocationList().GetLength(0);
----------------------------------------------------------

Comparing delegates of two different types assigned at compile-time results in a 
compilation error. If the delegate instances are statically of the type 
System.Delegate, then the comparison is allowed, but returns false at run time. For 
example:


---------------------------------------------------------------
delegate void Callback1();
delegate void Callback2();

static void method(Callback1 d, Callback2 e, System.Delegate f)
{
    // Compile-time error.
    Console.WriteLine(d == e);

    // OK at compile-time. False if the run-time type of f
    // is not the same as that of d.
    Console.WriteLine(d == f);
}
---------------------------------------------------------------